--- typecore.ml
+++ typecore.ml
@@ -6475,9 +6433,9 @@ and type_expect_
       in
       re { exp with exp_extra =
              (Texp_poly cty, loc, sexp.pexp_attributes) :: exp.exp_extra }
-  | Pexp_newtype(name, sbody) ->
+  | Pexp_newtype(name, jkind, sbody) ->
     type_newtype_expr ~loc ~env ~expected_mode ~rue ~attributes:sexp.pexp_attributes
-      name None sbody
+      name jkind sbody
   | Pexp_pack m ->
       (* CR zqian: pass [expected_mode] to [type_package] *)
       submode ~loc ~env Value.legacy expected_mode;
@@ -6684,7 +6642,11 @@ and type_expect_
            exp_attributes = sexp.pexp_attributes;
            exp_env = env }
   | Pexp_stack e ->
-      let exp = type_expect env expected_mode e ty_expected_explained in
+      let expected_mode' =
+        mode_morph (Value.join_with (Comonadic Areality) Regionality.Const.Local)
+          expected_mode
+      in
+      let exp = type_expect env expected_mode' e ty_expected_explained in
       let unsupported category =
         raise (Error (exp.exp_loc, env, Unsupported_stack_allocation category))
       in
@@ -6694,11 +6656,11 @@ and type_expect_
       | Texp_variant (_, Some (_, alloc_mode))
       | Texp_record {alloc_mode = Some alloc_mode; _}
       | Texp_array (_, _, _, alloc_mode)
-      | Texp_field (_, _, _, Boxing (alloc_mode, _)) ->
+      | Texp_field (_, _, _, Boxing (alloc_mode, _), _) ->
         begin match Locality.submode Locality.local
           (Alloc.proj (Comonadic Areality) alloc_mode.mode) with
         | Ok () -> ()
-        | Error _ -> raise (Error (exp.exp_loc, env,
+        | Error _ -> raise (Error (e.pexp_loc, env,
             Cannot_stack_allocate alloc_mode.locality_context))
         end
       | Texp_list_comprehension _ -> unsupported List_comprehension
@@ -6711,8 +6673,18 @@ and type_expect_
       | _ ->
         raise (Error (exp.exp_loc, env, Not_allocation))
       end;
+      submode ~loc ~env (Value.min_with (Comonadic Areality) Regionality.local)
+        expected_mode;
       let exp_extra = (Texp_stack, loc, []) :: exp.exp_extra in
       {exp with exp_extra}
+  | Pexp_comprehension comp ->
+      Language_extension.assert_enabled ~loc Comprehensions ();
+      type_comprehension_expr
+        ~loc
+        ~env
+        ~ty_expected
+        ~attributes:sexp.pexp_attributes
+        comp
 
 and expression_constraint pexp =
   { type_without_constraint = (fun env expected_mode ->
@@ -7727,7 +7699,8 @@ and type_argument ?explanation ?recarg env (mode : expected_mode) sarg
          pat_type = ty;
          pat_extra=[];
          pat_attributes = [];
-         pat_loc = Location.none; pat_env = env},
+         pat_loc = Location.none; pat_env = env;
+         pat_unique_barrier = Unique_barrier.not_computed () },
         {exp_type = ty; exp_loc = Location.none; exp_env = exp_env;
          exp_extra = []; exp_attributes = [];
          exp_desc =
@@ -8023,8 +7996,9 @@ and type_tuple ~loc ~env ~(expected_mode : expected_mode) ~ty_expected
   let expl =
     List.map2
       (fun (label, body) ((_, ty), argument_mode) ->
-        Option.iter (fun _ -> Jane_syntax_parsing.assert_extension_enabled ~loc
-                                Language_extension.Labeled_tuples ()) label;
+        Option.iter (fun _ ->
+             Language_extension.assert_enabled ~loc Labeled_tuples ())
+          label;
         let argument_mode = mode_default argument_mode in
         let argument_mode = expect_mode_cross env ty argument_mode in
           (label, type_expect env argument_mode body (mk_expected ty)))
@@ -8040,8 +8014,7 @@ and type_tuple ~loc ~env ~(expected_mode : expected_mode) ~ty_expected
 
 and type_unboxed_tuple ~loc ~env ~(expected_mode : expected_mode) ~ty_expected
       ~explanation ~attributes sexpl =
-  Jane_syntax_parsing.assert_extension_enabled ~loc Layouts
-    Language_extension.Beta;
+  Language_extension.assert_enabled ~loc Layouts Language_extension.Stable;
   let arity = List.length sexpl in
   assert (arity >= 2);
   let argument_mode = expected_mode.mode in
@@ -8079,8 +8052,9 @@ and type_unboxed_tuple ~loc ~env ~(expected_mode : expected_mode) ~ty_expected
   let expl =
     List.map2
       (fun (label, body) ((_, ty, sort), argument_mode) ->
-        Option.iter (fun _ -> Jane_syntax_parsing.assert_extension_enabled ~loc
-                                Language_extension.Labeled_tuples ()) label;
+        Option.iter (fun _ ->
+             Language_extension.assert_enabled ~loc Labeled_tuples ())
+          label;
         let argument_mode = mode_default argument_mode in
         let argument_mode = expect_mode_cross env ty argument_mode in
           (label, type_expect env argument_mode body (mk_expected ty), sort))
@@ -8122,11 +8096,7 @@ and type_construct env (expected_mode : expected_mode) loc lid sarg
     match sarg with
     | None -> []
     | Some se -> begin
-        match Jane_syntax.Expression.of_ast se with
-        | Some (( Jexp_comprehension _
-                | Jexp_immutable_array _
-                | Jexp_layout _), _) -> [se]
-        | None -> match se.pexp_desc with
+        match se.pexp_desc with
         | Pexp_tuple sel when
             constr.cstr_arity > 1 || Builtin_attributes.explicit_arity attrs
           ->
@@ -8694,18 +8664,11 @@ and type_function_cases_expect
 and type_let ?check ?check_strict ?(force_toplevel = false)
     existential_context env rec_flag spat_sexp_list allow_modules =
   let rec sexp_is_fun sexp =
-    match Jane_syntax.Expression.of_ast sexp with
-    | Some (jexp, _attrs) -> jexp_is_fun jexp
-    | None      -> match sexp.pexp_desc with
+    match sexp.pexp_desc with
     | Pexp_function _ -> true
     | Pexp_constraint (e, _, _)
-    | Pexp_newtype (_, e) -> sexp_is_fun e
+    | Pexp_newtype (_, _, e) -> sexp_is_fun e
     | _ -> false
-  and jexp_is_fun : Jane_syntax.Expression.t -> _ = function
-    | Jexp_comprehension _
-    | Jexp_immutable_array _
-    | Jexp_layout (Lexp_constant _) -> false
-    | Jexp_layout (Lexp_newtype (_, _, e)) -> sexp_is_fun e
   in
   let vb_is_fun { pvb_expr = sexp; _ } = sexp_is_fun sexp in
   let entirely_functions = List.for_all vb_is_fun spat_sexp_list in
@@ -9151,19 +9114,6 @@ and type_generic_array
     exp_attributes = attributes;
     exp_env = env }
 
-and type_expect_jane_syntax
-      ~loc ~env ~expected_mode ~ty_expected ~explanation ~rue ~attributes
-  : Jane_syntax.Expression.t -> _ = function
-  | Jexp_comprehension x ->
-      type_comprehension_expr
-        ~loc ~env ~expected_mode ~ty_expected ~explanation ~rue ~attributes x
-  | Jexp_immutable_array x ->
-      type_immutable_array
-        ~loc ~env ~expected_mode ~ty_expected ~explanation ~rue ~attributes x
-  | Jexp_layout x ->
-      type_jkind_expr
-        ~loc ~env ~expected_mode ~ty_expected ~explanation ~rue ~attributes x
-
 and type_expect_mode ~loc ~env ~(modes : Alloc.Const.Option.t) expected_mode =
     let min = Alloc.Const.Option.value ~default:Alloc.Const.min modes |> Const.alloc_as_value in
     let max = Alloc.Const.Option.value ~default:Alloc.Const.max modes |> Const.alloc_as_value in
@@ -9378,10 +9328,7 @@ and type_n_ary_function
    we need to provide modes while typechecking comprehensions, we will reference
    this comment by its incipit (the initial question, right at the start). *)
 
-and type_comprehension_expr
-      ~loc ~env ~expected_mode:_ ~ty_expected ~explanation:_ ~rue:_~attributes
-      cexpr =
-  let open Jane_syntax.Comprehensions in
+and type_comprehension_expr ~loc ~env ~ty_expected ~attributes cexpr =
   (* - [comprehension_type]:
          For printing nicer error messages.
      - [container_type]:
@@ -9393,18 +9340,20 @@ and type_comprehension_expr
      - [{body = sbody; clauses}]:
          The actual comprehension to be translated. *)
   let comprehension_type, container_type, make_texp,
-      {body = sbody; clauses}, jkind =
+      {pcomp_body = sbody; pcomp_clauses}, jkind =
     match cexpr with
-    | Cexp_list_comprehension comp ->
+    | Pcomp_list_comprehension comp ->
         (List_comprehension : comprehension_type),
         Predef.type_list,
         (fun tcomp -> Texp_list_comprehension tcomp),
         comp,
         Predef.list_argument_jkind
-    | Cexp_array_comprehension (amut, comp) ->
+    | Pcomp_array_comprehension (amut, comp) ->
         let container_type, mut = match amut with
           | Mutable   -> Predef.type_array, Mutable Alloc.Comonadic.Const.legacy
-          | Immutable -> Predef.type_iarray, Immutable
+          | Immutable ->
+              Language_extension.assert_enabled ~loc Immutable_arrays ();
+              Predef.type_iarray, Immutable
         in
         (Array_comprehension mut : comprehension_type),
         container_type,
@@ -9432,7 +9381,7 @@ and type_comprehension_expr
     (* To understand why we don't provide modes here, see "What modes should
        comprehensions use?", above *)
     type_comprehension_clauses
-      ~loc ~env ~comprehension_type ~container_type clauses
+      ~loc ~env ~comprehension_type ~container_type pcomp_clauses
   in
   let comp_body =
     (* To understand why comprehension bodies are checked at [mode_global], see
@@ -9455,8 +9404,8 @@ and type_comprehension_clauses
 
 (* Calls [reset_pattern] *)
 and type_comprehension_clause ~loc ~comprehension_type ~container_type env
-  : Jane_syntax.Comprehensions.clause -> _ = function
-  | For bindings ->
+  = function
+  | Pcomp_for bindings ->
       (* TODO: fix handling of first-class module patterns *)
       let tps = create_type_pat_state Modules_rejected in
       let tbindings =
@@ -9471,7 +9420,7 @@ and type_comprehension_clause ~loc ~comprehension_type ~container_type env
         add_pattern_variables ~check ~check_as:check env pvs
       in
       env, Texp_comp_for tbindings
-  | When cond ->
+  | Pcomp_when cond ->
       let tcond =
         (* To understand why [when] conditions can be checked at an arbitrary
            mode, see "What modes should comprehensions use?" in
@@ -9490,7 +9439,10 @@ and type_comprehension_binding
       ~container_type
       ~env
       tps
-      Jane_syntax.Comprehensions.{ pattern; iterator; attributes } =
+      { pcomp_cb_pattern = pattern;
+        pcomp_cb_iterator = iterator;
+        pcomp_cb_attributes = attributes }
+  =
   { comp_cb_iterator =
       type_comprehension_iterator
         ~loc ~env ~comprehension_type ~container_type tps pattern iterator
@@ -9499,9 +9451,8 @@ and type_comprehension_binding
   }
 
 and type_comprehension_iterator
-      ~loc ~env ~comprehension_type ~container_type tps pattern
-  : Jane_syntax.Comprehensions.iterator -> _ = function
-  | Range { start; stop; direction } ->
+      ~loc ~env ~comprehension_type ~container_type tps pattern = function
+  | Pcomp_range { start; stop; direction } ->
       let tbound ~explanation bound =
         (* To understand why [for ... = ...] iterator range endpoints can be
            checked at an arbitrary mode, see "What modes should comprehensions
@@ -9524,7 +9475,7 @@ and type_comprehension_iterator
           ~param:pattern
       in
       Texp_comp_range { ident; pattern; start; stop; direction }
-  | In seq ->
+  | Pcomp_in seq ->
       let item_ty = newvar (Jkind.Builtin.any ~why:Dummy_jkind) in
       let seq_ty = container_type item_ty in
       let sequence =
@@ -9559,41 +9510,9 @@ and type_comprehension_iterator
       in
       Texp_comp_in { pattern; sequence }
 
-and type_immutable_array
-      ~loc ~env ~expected_mode ~ty_expected ~explanation ~rue:_ ~attributes
-    : Jane_syntax.Immutable_arrays.expression -> _ = function
-  | Iaexp_immutable_array elts ->
-      type_generic_array
-        ~loc
-        ~env
-        ~expected_mode
-        ~ty_expected
-        ~explanation
-        ~mutability:Immutable
-        ~attributes
-        elts
-
-and type_jkind_expr
-      ~loc ~env ~expected_mode ~ty_expected:_ ~explanation:_ ~rue ~attributes
-  : Jane_syntax.Layouts.expression -> _ = function
-  | Lexp_constant x -> type_unboxed_constant ~loc ~env ~rue ~attributes x
-  | Lexp_newtype (name, jkind_annot, sbody) ->
-    type_newtype_expr ~loc ~env ~expected_mode ~rue ~attributes
-      name (Some jkind_annot) sbody
-
-and type_unboxed_constant ~loc ~env ~rue ~attributes cst =
-  let cst = unboxed_constant_or_raise env loc cst in
-  rue {
-    exp_desc = Texp_constant cst;
-    exp_loc = loc;
-    exp_extra = [];
-    exp_type = type_constant cst;
-    exp_attributes = attributes;
-    exp_env = env }
-
 (* Typing of method call *)
 and type_send env loc explanation e met =
-  let obj = type_exp env mode_legacy e in
+  let obj = type_exp env mode_object e in
   let (meth, typ) =
     match obj.exp_desc with
     | Texp_ident(_, _, {val_kind = Val_self(sign, meths, _, _)}, _, _) ->
